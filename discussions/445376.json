[
  {
    "Id": "1050327",
    "ThreadId": "445376",
    "Html": "Hey :).\r<br />\n<br />\nI try to generate all voronoi polygons. But i cant figure out how to retrieve the vertices and their triangle indices.\r<br />\n<br />\nI need this in Unity to create a mesh.\r<br />\n<br />\nThe delaunay triangulation provides already the triangle indices and vertices (RenderData).\r<br />\nIs there a similiar way to get this done?\r<br />\n<br />\nI  previously tried to loop over the Voronoi.Regions and their vertices. I connected the corners and the generator with some Debug.DrawLine to see how they are generated.\r<br />\n<br />\nBut I don't get it.\r<br />\n<br />\nThanks in advance!<br />\n",
    "PostedDate": "2013-05-29T14:14:23.66-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050353",
    "ThreadId": "445376",
    "Html": "Not exactly sure what you're trying to do:\r<br />\n<br />\n<em>&gt; I try to generate all voronoi polygons. But i cant figure out how to retrieve the vertices and their triangle indices.</em> \r<br />\n<br />\nSo you got the Voronoi diagram of a point set (or polygon?), i.e. the region information and the points. And you want to know the triangle a Voronoi vertex lies in?\r<br />\n<br />\n<em>&gt; I previously tried to loop over the Voronoi.Regions and their vertices. I connected the corners and the generator with some Debug.DrawLine to see how they are generated.</em>\r<br />\n<br />\nIf you are trying get the original triangulation back from the Voronoi diagram, this is not the right way. The Voronoi vertices are not part of the Delaunay triangulation.<br />\n",
    "PostedDate": "2013-05-29T15:40:21.513-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050792",
    "ThreadId": "445376",
    "Html": "I'm sorry for my bad explanation. Second try ;)<br />\n<br />\nTo start with your library I created a plane mesh with the points from the delaunay diagram. It was easy to understand and it was straight forward:<br />\n<pre><code>        private TriangleNet.Mesh _mesh;\n        private TriangleNet.Render.RenderData _renderData\n\n        var points = 5;\n        var width= 100;\n        var height= 100;\n\n        TriangleNet.Geometry.InputGeometry geometry = new TriangleNet.Geometry.InputGeometry(points);\n\n        for (int i = 0; i &lt; points; i++)\n            {\n            geometry.AddPoint(rnd.NextDouble() * width, rnd.NextDouble() * height);\n        }\n\n        _mesh = new TriangleNet.Mesh();\n        _mesh.SetOption(Options.ConformingDelaunay, true);\n        _mesh.Triangulate(geometry);\n\n        _renderData.SetInputGeometry(geometry);\n        _renderData.SetMesh(_mesh);\n\n        //Unity BuildIn Mesh-Class\n        UnityEngine.Mesh uMesh = new UnityEngine.Mesh();\n\n        uMesh.vertices = _mesh.Vertices; //add the delaunay vertices to the unity mesh\n\n        //Unity needs triangle indices to create the triangles out of the mesh vertices\n        //example: [0, 1, 2,   2, 3, 1]\n        //_renderData.Triangles supports already counter clockwise indices (ID) / Vertex.P0 -&gt; this.vertices[0].id\n        uMesh.triangles =  _renderData.Triangles;</code></pre>\n\nWith the code above I was able to create this mesh:<br />\n<br />\n<img src=\"https://dl.dropboxusercontent.com/u/28056956/delaunayMesh.png\" alt=\"Image\" /><br />\n<br />\nNow I want to create a plane mesh with voronoi data. Initially I start to &quot;debug&quot; the diagram by connecting the the points from a region with lines. If I'm right, every center from a voronoi region (Vertex.Generator) is a point in a delaunay triangle.<br />\n<br />\nMy &quot;debug&quot; code:<br />\n<pre><code>        private TriangleNet.Mesh _mesh;\n        private TriangleNet.Tools.Voronoi _voronoi;\n        private TriangleNet.Render.RenderData _renderData\n\n        var points = 5;\n        var width= 100;\n        var height= 100;\n\n        TriangleNet.Geometry.InputGeometry geometry = new TriangleNet.Geometry.InputGeometry(points);\n\n        for (int i = 0; i &lt; points; i++)\n            {\n            geometry.AddPoint(rnd.NextDouble() * width, rnd.NextDouble() * height);\n        }\n\n        _mesh = new TriangleNet.Mesh();\n        _mesh.SetOption(Options.ConformingDelaunay, true);\n        _mesh.Triangulate(geometry);\n        _voronoi = new TriangleNet.Tools.Voronoi(_mesh)\n\n        _renderData.SetInputGeometry(geometry);\n        _renderData.SetMesh(_mesh);\n        _renderData.SetVoronoi(_voronoi);\n\n    foreach (var region in _voronoi.Regions) {\n        \n        //Try to get a &quot;whole&quot; polygon\n        if (!region.Bounded) {\n            continue;\n        }\n        \n        //Draw the probably center of the polygon\n        Debug.DrawLine(new Vector3((float)region.Generator.X, 0f, (float)region.Generator.Y),\n                new  Vector3((float)region.Generator.X, 0.5f, (float)region.Generator.Y),\n                Color.red);\n        \n        //Connect every edge? with the polygon center\n        //The code works like the Triangle.NET GDI+ VoronoiRendere\n        for (int i = 0; i &lt; region.Vertices.Count; i++) {\n                \n            var ci0 = i;\n            var ci1 = i + 1;\n                \n            if (ci1 == region.Vertices.Count) {\n                ci1 = 0;\n            }\n\n            var center = item.Generator;    \n            var corner0 = item.Vertices[ci0];\n            var corner1 = item.Vertices[ci1];\n                \n            Debug.DrawLine(new Vector3((float)corner0.X, 0.0f, (float)corner0.Y),\n                    new  Vector3((float)corner1.X, 0.0f, (float)corner1.Y),\n                    Color.magenta);\n\n            Debug.DrawLine(new Vector3((float)corner0.X, 0.0f, (float)corner0.Y),\n                    new  Vector3((float)center.X, 0.0f, (float)center.Y),\n                    Color.magenta);\n\n            Debug.DrawLine(new Vector3((float)corner1.X, 0.0f, (float)corner1.Y),\n                    new  Vector3((float)center.X, 0.0f, (float)center.Y),\n                    Color.magenta);\n        }\n    }\n</code></pre>\n\nThis is what I got:<br />\n<br />\n<img src=\"https://dl.dropboxusercontent.com/u/28056956/voronoiPolygon.png\" alt=\"Image\" /><br />\n<br />\nEach blue circle in the picture above represents a vertex in the Voronoi.Regions[0].Vertices. The green circle (small red line) is the center / the Voronoi.Region.Generator.<br />\n<br />\nNow I need the (ordered?) vertices and a related and correct sorted triangle indices array like the _renderData.Triangles from the delaunay diagram to create the mesh in unity.<br />\n<br />\nAnd I don't know how to do this. <br />\n<br />\nI hope this illustration is better than the one before :).<br />\n<br />\nThank you for helping me out!<br />\n<br />\nPS: Some background, I want to create a terrain with the voronoi polygons :D.<br />\n",
    "PostedDate": "2013-05-30T11:50:49.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050888",
    "ThreadId": "445376",
    "Html": "I'm not familiar with Unity, so I can't give you any advice on that one.<br />\n<br />\nIf I understand right, you have the Voronoi data and want to convert it to the usual 3D mesh datastructure, i.e. vertex array and triangle indices array, with triangle indices sorted consistently!?<br />\n<br />\nThe VoronoiRegion.Vertices should already be sorted counterclockwise and have unique ids. So if you want to build triangles by connecting the two vertices of a Voronoi edge with the cells generator, the resulting triangle will also be oriented counterclockwise (regardless of positioning the generator before or after the two edge vertices). The only thing you have to worry about, is assigning an unused id to the generator vertex. The easiest way would probably be finding the largest Voronoi vertex id (actually I think, as the mesh triangles are numbered from 0 to N, the highest id will also be N) and then using values higher than that id for the generators.<br />\n<br />\nThis shouldn't be too hard to code, I'm sure you can work that out. Anyway, feel free to come back if you get stuck...<br />\n",
    "PostedDate": "2013-05-30T15:09:17.72-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1052825",
    "ThreadId": "445376",
    "Html": "You have no idea how stupid I felt! It took me more than a few hours to realize my mistakes.<br />\n<br />\nI tried to get the vertices by looping over the regions and add the vertices to a new list. My first mistake was to add these to the list without checking for duplicated vertices. The second mistake was to try it with unsorted vertices. To create the triangles I have to sort the vertices by their id. The clue is to use the Voronoi.Points. They are already sorted in the correct way.<br />\n<br />\nAfter that I saved the current vertices count as &quot;offset-index&quot; and then I added the generator vertices at the end of my new list.<br />\n<br />\nTo create the triangle indices I went over the regions and the associated vertices, grabbed the id and finally added the generator id (id + the &quot;offset-index&quot;) to the end.<br />\n<br />\nIn fact that was the whole magic.<br />\n<br />\nThanks for your support! Your post helped me!<br />\n<br />\nHere is an example of the generated mesh:<br />\n<br />\n<img src=\"https://dl.dropboxusercontent.com/u/28056956/voronoiTerrain.png\" alt=\"Image\" /><br />\n<br />\nFor the sake of completeness I leave some code to provide a sample if someone will do the same.<br />\nI know it's not the best piece of code and of course it also needs some improvements. I think in the near future I'll port this to a gp-gpu shader in unity to speed up the generation.<br />\n<pre><code>\n    void Start () {\n        \n        var points = 50;\n        var width= 100;\n        var height= 100;\n        \n        System.Random rnd = new System.Random(System.DateTime.Now.Millisecond);\n        TriangleNet.Geometry.InputGeometry geometry = new TriangleNet.Geometry.InputGeometry(points);\n        \n        for (int i = 0; i &lt; points; i++)\n            {\n                    geometry.AddPoint(rnd.NextDouble() * width,\n                            rnd.NextDouble() * height);\n            }\n        \n        _mesh = new TriangleNet.Mesh();\n        _mesh.SetOption(Options.ConformingDelaunay, true);\n        \n        _mesh.Triangulate(geometry);\n        _voronoi = new TriangleNet.Tools.Voronoi(_mesh);\n        \n        _renderData = new TriangleNet.Render.RenderData();      \n        \n        _renderData.SetInputGeometry(geometry);\n        _renderData.SetMesh(_mesh);\n        _renderData.SetVoronoi(_voronoi);\n\n        var voronoiVertices = new List&lt;Vector3&gt;();\n        var triangles = new List&lt;int&gt;();\n            \n        foreach (var point in _voronoi.Points) {\n            voronoiVertices.Add(new Vector3((float)point.X, 0f, (float)point.Y));\n        }\n\n        \n        int verticesCount = voronoiVertices.Count;\n\n        foreach (var item in _voronoi.Regions) {\n            voronoiVertices.Add(new Vector3((float)item.Generator.X, 0f, (float)item.Generator.Y));\n\n        }\n\n        foreach (var item in _voronoi.Regions) {\n            if (!item.Bounded) {\n                continue;\n            }\n            \n            for (int i = 0; i &lt; item.Vertices.Count; i++) {\n                \n                var ci0 = i;\n                var ci1 = i + 1;\n                \n                if (ci1 == item.Vertices.Count) {\n                    ci1 = 0;\n                }\n                \n                var corner0 = item.Vertices[ci0].ID;\n                var corner1 = item.Vertices[ci1].ID;\n                var center = item.Generator.ID;\n                \n                triangles.Add(corner0);\n                triangles.Add(corner1);\n                triangles.Add(center + verticesCount);\n                \n            }\n        }\n\n        UnityEngine.Mesh uMesh = new UnityEngine.Mesh();\n        \n            GameObject HexiSphereSegment = new GameObject();\n\n            HexiSphereSegment.transform.parent = base.transform;\n            HexiSphereSegment.transform.localPosition = Vector3.zero;\n            HexiSphereSegment.transform.rotation = base.transform.rotation;\n        \n            HexiSphereSegment.AddComponent&lt;MeshRenderer&gt;();\n            MeshFilter filter = HexiSphereSegment.AddComponent&lt;MeshFilter&gt;();\n            HexiSphereSegment.renderer.material= base.renderer.material;\n        \n\n            HexiSphereSegment.name = &quot;Forward&quot;;\n        Vector2[] _uv2D = new Vector2[voronoiVertices.Count];\n        \n        for(int x = 0; x &lt; voronoiVertices.Count; x++){\n            _uv2D[x] = new Vector2(voronoiVertices[x].x, voronoiVertices[x].y);\n        }\n\n        uMesh.hideFlags = HideFlags.DontSave;\n        uMesh.vertices = voronoiVertices.ToArray();\n            uMesh.uv = _uv2D;\n            uMesh.triangles =  triangles.ToArray();\n        uMesh.RecalculateNormals();\n            uMesh.RecalculateBounds();\n            filter.mesh = uMesh;\n    }\n</code></pre>\n\nPS: the mesh in unity is by default upside down. Change Y and Z rotation to 180 degrees! :)<br />\n",
    "PostedDate": "2013-06-04T14:39:27.577-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1133112",
    "ThreadId": "445376",
    "Html": "Thanks for quick replay\r<br />\n<br />\nIts works<br />\n",
    "PostedDate": "2013-12-09T05:03:18.88-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1236442",
    "ThreadId": "445376",
    "Html": "We implemented Triangle voronoi in <a href=\"http://www.mattermachine.com\" rel=\"nofollow\">MatterMachine</a>.  It was all a little easier because of this thread and others.  So we thought we'd share our implementation.  It's somewhat tied to how we evaluate our 'operators', and how we represent our meshes (PolyMesh), but there's plenty to get here if you can ignore that.<br />\n<br />\nEssentially, the input is one or more curves (order 2 NurbsCurves, so essentially polylines).  The second etc curve can be treated like holes.  In that case we use a trick to find a point inside the (potentially) convex hole.<br />\n<br />\n<a href=\"https://www.dropbox.com/s/0des3rrv528opgx/Screen%20Shot%202014-04-22%20at%205.16.05%20pm.png\" rel=\"nofollow\">Here's what it looks like</a>.<br />\n<pre><code>\n  using UnityEngine;\n  using System;\n  using System.Collections;\n  using System.Collections.Generic;\n  using MM.Primitives;\n  using MM.Types;\n  using MM.Util;\n  using Ayam.Nurbs;\n  using TriangleNet.Geometry;\n  using TriangleNet.Tools;\n\n\n  namespace MM.Operators\n  {\n    public class Voronoi: Operator, IOperator\n    {\n        public int mode;  // 0 = holes, 1 = every curve a poly\n        public int voronoi;  // 0 = meshes, 1 = curves, 2 = centers\n        public bool asOneMesh;\n        public bool bounded;\n        public bool convexHull;\n        public bool preFlatten;\n        \n        public int algorithm;  // 0 = sweepline, 1 = Dwyer, 2 = incremental\n\n        public bool refine;\n        public bool conformingDelauney = true;  // seems to fail most of the time if false\n        public double maxArea;\n        public double minAngle;\n        public double maxAngle;\n        \n        public int smoothing;\n        \n        public double maxRunTime;\n        \n        // internal points are added to create vertices inside the triangulated polygon\n        public List&lt;mmVector3&gt; internalPoints;\n        \n        public Voronoi()\n        {\n            internalPoints = new List&lt;mmVector3&gt;();\n        }\n        \n        \n        public bool Cook()\n        {\n            if ( !IsBound ( &quot;internalPoints&quot; ) )\n                internalPoints = new List&lt;mmVector3&gt;();\n\n            //  FIXME getting error when refine == false &amp;&amp; internalPoints.Count &gt; 0\n            // to do with using BoundedVoronoi instead of Voronoi\n  //            Triangle.cs error: System.IndexOutOfRangeException: Array index is out of range.\n  //                    at TriangleNet.Tools.BoundedVoronoi.ConstructBvdCell\n                    \n            if ( refine == false &amp;&amp; internalPoints.Count &gt; 0 ) {\n                errorMessage = &quot;please switch on refinement when providing inner points&quot;;\n                return false;\n            }\n\n            bool foundCurve = false;\n            bool foundOrderTwoCurve = false;\n            var curves = new List&lt;NurbsCurve&gt;();\n            \n            foreach ( Primitive primitive in inputGeometry ) {\n                if ( primitive is NurbsCurve ) {\n                    foundCurve = true;\n                    var curve = primitive as NurbsCurve;\n                    \n                    if ( curve.order == 2 ) {\n                        foundOrderTwoCurve = true;\n                        \n                        if ( preFlatten ) {\n                            foreach ( mmVector3 point in curve.points )\n                                point.y = 0;\n                        }\n                        else {\n                            foreach ( mmVector3 point in curve.points ) {\n                                if ( point.y &gt; Double.Epsilon ) {\n                                    errorMessage = &quot;contours curve must lie in XZ (Y=0) plane&quot;;\n                                    return false;\n                                }\n                            }\n                        }\n                        \n                        // avoid overlapping end points\n                        if ( ( curve.points[ 0 ].x - curve.points[ curve.points.Count - 1 ].x &lt;= Double.Epsilon ) &amp;&amp; ( curve.points[ 0 ].z - curve.points[ curve.points.Count - 1 ].z &lt;= Double.Epsilon ) ) {\n  //                            Logging.Error( &quot;removing endpoint&quot; );\n                            curve.points.RemoveAt ( 0 );\n                        }\n                        \n                        curves.Add ( curve );\n                    }\n                }\n                else outputGeometry.Add ( primitive );\n            }\n            \n            \n            if ( foundCurve &amp;&amp; !foundOrderTwoCurve ) {\n                errorMessage = &quot;triangulation only works on order 2 curves&quot;;\n                return false;\n            }\n\n            try {\n                if ( curves.Count &gt; 0 ) {\n                    if ( mode == 0 ) {  // 1st curve is outer boundary, other curves are holes\n                        Triangle ( curves );\n                    } else {  // each curve represents a separate polygon\n                        foreach ( var curve in curves )\n                            Triangle ( new List&lt;NurbsCurve&gt;() { curve } );\n                    }\n                }\n            }\n            catch ( Exception e ) {\n                Logging.Error ( &quot;Triangle.cs error: &quot; + e );\n                errorMessage = &quot;triangulation failed - try other settings&quot;;\n                return false;\n            }\n\n            return true;\n        }\n\n\n\n        \n        // https://triangle.codeplex.com/\n        private void Triangle ( List&lt;NurbsCurve&gt; curves )\n        {\n            var curve = curves[ 0 ];\n            var inputGeo = new InputGeometry ( curve.points.Count );\n            \n            for ( int i = 0; i &lt; curve.points.Count; i++ ) {\n                inputGeo.AddPoint ( curve.points[i].x, curve.points[i].z, 1 );\n                inputGeo.AddSegment ( i, ( i + 1 ) % curve.points.Count, 1 );\n            }\n            \n            var mesh = new TriangleNet.Mesh();\n            \n            var numPoints = inputGeo.Count;\n            \n            for ( int j = 1; j &lt; curves.Count; j++ ) {\n                curve = curves[ j ];\n                \n                for ( int i = 0; i &lt; curve.points.Count; i++ )\n                    inputGeo.AddPoint ( curve.points[i].x, curve.points[i].z, j + 1 );\n                \n                for ( int i = numPoints; i &lt; inputGeo.Count - 1; i++ )\n                    inputGeo.AddSegment ( i, i + 1, j + 1 );\n                inputGeo.AddSegment ( inputGeo.Count - 1, numPoints, j + 1 );\n                \n                // find a point that lies in the hole (Triangle quirkiness)\n                // somewhat naive: construct a series of candidate points (two per vertex) and test until positive\n                mmVector3 delta = .01f * MiscUtil.GetBounds( curve.points ).size;\n                if ( curve.points.Count &gt; 2 ) {\n                    for ( int i = 0; i &lt; curve.points.Count - 1; i++ ) {\n                        if ( IsPointInPolygon( curve.points[i] + delta, curve.points ) ) {\n                            inputGeo.AddHole( curve.points[i].x + delta.x, curve.points[i].z + delta.z );\n                            break;\n                        }\n                        if ( IsPointInPolygon( curve.points[i] - delta, curve.points ) ) {\n                            inputGeo.AddHole( curve.points[i].x - delta.x, curve.points[i].z - delta.z );\n                            break;\n                        }\n                    }\n                }\n                \n                numPoints += curve.points.Count;\n            }\n            \n            \n            // add inner points\n            foreach ( mmVector3 innerPoint in internalPoints )\n                inputGeo.AddPoint ( innerPoint.x, innerPoint.z, 0 );\n            \n            \n            if ( convexHull )\n                mesh.Behavior.Convex = true;\n            \n            if ( algorithm == 0 )\n                mesh.Behavior.Algorithm = TriangleNet.TriangulationAlgorithm.SweepLine;  // seems most stable\n            else if ( algorithm == 1 )\n                mesh.Behavior.Algorithm = TriangleNet.TriangulationAlgorithm.Dwyer;\n            else\n                mesh.Behavior.Algorithm = TriangleNet.TriangulationAlgorithm.Incremental;\n            \n            mesh.Triangulate ( inputGeo );\n            \n            if ( refine ) {\n                mesh.Behavior.ConformingDelaunay = conformingDelauney;\n                mesh.Behavior.MinAngle = minAngle;\n                mesh.Behavior.MaxAngle = maxAngle;\n                mesh.Behavior.MaxArea = maxArea;\n                mesh.Refine();\n            }\n            \n            for ( int i = 0; i &lt; smoothing; i++ )\n                mesh.Smooth();\n\n            var voronoiData = new BoundedVoronoi ( mesh, bounded );\n            if ( voronoi == 0 ) {\n                if ( asOneMesh ) {\n                    outputGeometry.Add ( new PolyMesh ( voronoiData ) );\n                } else {\n                    foreach ( var region in voronoiData.Regions )\n                        outputGeometry.Add ( new PolyMesh ( region ) );\n                }\n            }\n            else if ( voronoi == 1 )  // outputs a Polyline for every region\n            {\n                foreach ( var region in voronoiData.Regions )\n                {\n                    if (!region.Bounded) continue;\n                    \n                    var regionBoundary = new NurbsCurve ();\n                    regionBoundary.order = 2;\n                    \n                    foreach ( var vertex in region.Vertices )\n                        regionBoundary.points.Add ( new mmVector3 ( vertex.X, 0f, vertex.Y ) );\n                    regionBoundary.points.Add ( new mmVector3 ( region.Vertices[ 0 ].X, 0f, region.Vertices[ 0 ].Y ) );\n                    \n                    regionBoundary.knotVector = NurbsLibCore.GenerateKnotVector ( 2, regionBoundary.points.Count );\n                    outputGeometry.Add ( regionBoundary );\n                }\n            } else {   // centers\n                var markers = new PositionsPrimitive ();\n                foreach ( var region in voronoiData.Regions )\n                    markers.points.Add ( new mmVector3 ( region.Generator.X, 0f, region.Generator.Y ) );\n                outputGeometry.Add ( markers );\n            }\n        }\n        \n        // http://stackoverflow.com/questions/217578/point-in-polygon-aka-hit-test\n        private bool IsPointInPolygon( mmVector3 p, List&lt;mmVector3&gt; polygon )\n        {\n            double minX = polygon[ 0 ].x;\n            double maxX = polygon[ 0 ].x;\n            double minY = polygon[ 0 ].z;\n            double maxY = polygon[ 0 ].z;\n            for ( int i = 1 ; i &lt; polygon.Count ; i++ )\n            {\n                var q = polygon[ i ];\n                minX = Math.Min( q.x, minX );\n                maxX = Math.Max( q.x, maxX );\n                minY = Math.Min( q.z, minY );\n                maxY = Math.Max( q.z, maxY );\n            }\n            \n            if ( p.x &lt; minX || p.x &gt; maxX || p.z &lt; minY || p.z &gt; maxY )\n            {\n                return false;\n            }\n            \n            // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n            bool inside = false;\n            for ( int i = 0, j = polygon.Count - 1 ; i &lt; polygon.Count ; j = i++ )\n            {\n                if ( ( polygon[ i ].z &gt; p.z ) != ( polygon[ j ].z &gt; p.z ) &amp;&amp;\n                    p.x &lt; ( polygon[ j ].x - polygon[ i ].x ) * ( p.z - polygon[ i ].z ) / ( polygon[ j ].z - polygon[ i ].z ) + polygon[ i ].x )\n                {\n                    inside = !inside;\n                }\n            }\n            \n            return inside;\n        }\n        \n    }\n  }\n</code></pre>\n\n",
    "PostedDate": "2014-04-22T01:35:01.397-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1236448",
    "ThreadId": "445376",
    "Html": "And this is how we convert back to our PolyMesh format, using BoundedVoronoi:<br />\n<pre><code>\n        // convert from TriangleNet.Tools.BoundedVoronoi\n        public PolyMesh ( TriangleNet.Tools.BoundedVoronoi voronoi )\n        {\n            var voronoiRegions = voronoi.Regions;\n\n            int vertexCount = 0;\n            \n            foreach (var region in voronoiRegions)\n            {\n                if (!region.Bounded) continue;\n                \n                points.Add ( new mmVector3 ( region.Vertices[0].X, 0f, region.Vertices[0].Y ) );\n                \n                for (int i = 1; i &lt; region.Vertices.Count - 1; i++)\n                {\n                    points.Add ( new mmVector3 ( region.Vertices[i].X, 0f, region.Vertices[i].Y ) );\n                    triangles.Add ( new Triangle ( vertexCount, vertexCount + i, vertexCount + i + 1, this ) );\n                }\n                \n                points.Add ( new mmVector3 ( region.Vertices[ region.Vertices.Count - 1 ].X, 0f, region.Vertices[ region.Vertices.Count - 1 ].Y ) );\n\n                vertexCount += region.Vertices.Count;\n            }\n        }\n\n        public PolyMesh ( TriangleNet.Tools.VoronoiRegion region )\n        {\n            points.Add ( new mmVector3 ( region.Vertices[0].X, 0f, region.Vertices[0].Y ) );\n            \n            for (int i = 1; i &lt; region.Vertices.Count - 1; i++)\n            {\n                points.Add ( new mmVector3 ( region.Vertices[i].X, 0f, region.Vertices[i].Y ) );\n                triangles.Add ( new Triangle ( 0, i, i + 1, this ) );\n            }\n            \n            points.Add ( new mmVector3 ( region.Vertices[ region.Vertices.Count - 1 ].X, 0f, region.Vertices[ region.Vertices.Count - 1 ].Y ) );\n        }\n</code></pre>\n\n",
    "PostedDate": "2014-04-22T01:38:38.35-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]