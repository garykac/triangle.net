[
  {
    "Id": "1464154",
    "ThreadId": "651675",
    "Html": "Dear wo80, \r<br />\nFirst I would like to thank you for this great contribution.\r<br />\n<br />\n<br />\nI am working on a tool using your libary and having some speed issues using the <strong>insertVertex</strong> method and <strong>VertexCirculator</strong> class.\r<br />\nI am iteratively inserting a new vertex at the time into an exising delaunay ( created with triangle.net) After every vertex inserted I need to find the adjacent triangles \r<br />\nto calculate distances via circumference circle. I am currently using the following workflow below at each iteration and have a few questions:\r<br />\n<br />\n<br />\nA: can <strong>var circulator</strong> ( vertexCirculator) be updated each iteration rather than newly instanciated every iteration.\r<br />\nB: Is there a way to get the boundary triangles already as a <strong>result of the insertVertex Method</strong> ?\r<br />\nC: To insert a the Vertex I am using a dummytri for the otri .. Sometimes this results in a nullexception at the locationsearch. Therefore I built this workaround (below) and changed some codein the mesh.cs to not precise.locate when a triangle[0] is given .. Any suggestions how to solve the issue in a cleaner way ? <br />\n<pre><code>  ///////////// INSERT VERTEX IN MESH /////\n\n TriangleNet.Topology.Otri otri3 = default(TriangleNet.Topology.Otri);\n TriangleNet.Topology.Osub osub3 = default(TriangleNet.Topology.Osub);\n osub3.seg = null;\n TriangleNet.Geometry.Vertex myvertex = new TriangleNet.Geometry.Vertex(pN.X, pN.Y);\n\n\n while (true)\n    {\n      try\n         {\n          otri3.tri = triangleNetMesh.dummytri;\n          var res = triangleNetMesh.InsertVertex(myvertex, ref otri3, ref osub3, false, false);\n          resInt = (int)res;\n          break;\n          }\n          catch\n                {\n                 List&lt;TriangleNet.Topology.Triangle&gt; netTriangle = new                \n                 List&lt;TriangleNet.Topology.Triangle&gt;(triangleNetMesh.Triangles);\n                 otri3.tri = netTriangle[0];\n                 var res = triangleNetMesh.InsertVertex(myvertex, ref otri3, ref osub3, false, false);\n                 resInt = (int)res;\n                 break;\n                  }\n       }\n\nvar vertices = triangleNetMesh.Vertices.ToList();\nTriangleNet.Geometry.Vertex insertedVertex = vertices[vertices.Count - 1];\nvar circulator = new TriangleNet.Meshing.Iterators.VertexCirculator(triangleNetMesh);\nIEnumerable&lt;TriangleNet.Geometry.ITriangle&gt; EnumAdjacentTriangles;\nEnumAdjacentTriangles = circulator.EnumerateTriangles(insertedVertex);\n                </code></pre>\n\nThanks in advance \r<br />\nBest\r<br />\nChristoph <br />\n",
    "PostedDate": "2016-02-23T06:47:10.137-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1464293",
    "ThreadId": "651675",
    "Html": "<ol>\n<li>\nThe speed of the incremental Delaunay algorithm largely depends on the speed of triangle location. So, depending on your problem, you should know a good starting triangle before calling the <code>InsertVertex</code> method.<br />\n</li>\n<li>\nThe <code>InsertVertex</code> method might fail for non-convex meshes (see <code>TriangleLocator</code> class). That's probably why you get the exceptions. Don't try to work around this (while-loop and try-catch). You will need some kind of point location (see <a href=\"http://www.iue.tuwien.ac.at/phd/fasching/node82.html\" rel=\"nofollow\">Kirkpatrick's algorithm</a> as an example (efficient, but not the easiest to understand)).<br />\n</li>\n<li>\nDepending on the size of your mesh, doing <code>new List&lt;Triangle&gt;(mesh.Triangles)</code> or <code>mesh.Vertices.ToList()</code> is a bad idea (lots of unnecessary memory allocations). Use LINQ instead (<code>mesh.Triangles.First()</code>, <code>mesh.Vertices.Last()</code>).<br />\n</li>\n<li>\nAvoid using the <code>VertexCirculator</code> class: On successful return of <code>InsertVertex</code>, the <code>searchtri</code> parameter will point to a triangle that has the inserted vertex as it's origin. You can start iterating from that triangle. If you can be sure that the inserted vetrex will not lie on the mesh boundary, getting the adjacent triangles is very simple (look at the <code>VertexCirculator</code> implementation - you only need the first while-loop of <code>BuildCache</code>).<br />\n</li>\n</ol>\n",
    "PostedDate": "2016-02-23T15:39:12.753-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]